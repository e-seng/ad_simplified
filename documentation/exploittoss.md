# ExploitToss

A plug and play solution to run exploit scripts throughout an attack &
defense-styled CTF.

This is made with the intention of either importing or copying the code into
another solve script and avoid learning FlagWarehouse. This ensures that the
exploits are being thrown at all correct servers with the correct information,
and keep doing so for the entire duration of the competition.

## Usage

To use this script, this repository should be saved to the same file directory
as the solve script.

```sh
git clone https://github.com/e-seng/ad_simplified.git
```

Afterwards, the function to use, `run_exploits(...)`, can be made accessible via
the following line.

```py
from ad_simplified.exploittoss import run_exploits
```

> Alternatively, the code can just be copied into a solve script... I will
> simply beg for attribution. If copied, the code from the `START HERE` line to
> the `END HERE` line

Typcial use requires some configuration, but in general the function accepts
four positional parameters.

### positional parameters (in order)

| parameter name    | value type | purpose                                       |
|:---               |   :---:    | :--                                           |
|`exploit`          | function   | The exploit function with 3 parameters itself, namely `host`, `port` and  `data`|
|`challenge_name`   | str        | The name of the challenge as found on the `teams.json` file. If the provided name cannot be found, it will attempt to exploit the service on all teams without additional data |
|`challenge_port`   | int        | The port the challenge is hosted on |
|`exploiter_team_id`| str        | The running team's team indentification to avoid running on own services |

Please see [# defining your exploit function](#defining-your-exploit-function)
for additional info on the `exploit` parameter.

### optional parameters

| parameter name    | value type | purpose                                       |
|:---               |   :---:    | :--                                           |
|`team_json_url`    | str        | The url to fetch tick information from (should be altered for the specific CTF) |
|`tick_duration`    | int        | The number of seconds between each tick
|`team_id_format`   | str        | A way to generate the host address to run exploits against if it is not simply the team id. The exact pattern it will replace in this string is `<team-id>`. See below for an example. |
|`json_timeout`     | int        | Number of seconds to wait before timing out the request for team information |
|`nop_only`         | bool       | A flag to determine whether exploits should only be run against the nop team |
|`verbose`          | bool       | A flag to determine whether progress information should be printed |
|`debug`            | bool       | A flag to determine whether developer information should be printed |

## defining your exploit function

Exploit functions expect exactly three positional parameters: `host`, `port` and
`data`. The challenge to exploit is expected to be hosted at `<host>:<port>` for
every team playing. The third parameter, `data` is additional information
provided by `teams.json` to acquire the flag at the current tick.

For example, consider a LFI exploit at endpoint `<host>:<port>/images?path=...`,
where the absolute path of the flag is provided by `teams.json`. The
corresponding exploit function will look similar to the following.

```py
import requests

def exploit_lfi(host, port, flag_path):
    response = requests.get(
            f"{host}:{port}/images?path=\x2b\x22../../../{flag_path}")
    # then more logic to send the flag to the submission server
```

This function can then be used with the exploit runner using the following code
(assuming minor adjustments)

```py
if __name__ == "__main__": # mostly only for formality I suppose
    run_exploits(exploit_lfi,
                 "LFI Challenge",
                 1337, # challenge port number
                 42) # team id
```
